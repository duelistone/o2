// search.c

#include "search.h"

// Generated by quick helper program
// These are masks for the squares that can't be affected with a play in a given square
u64 SAFE_MASK[64] = {
    89893233717108159ull,
    9340377347262885855ull,
    9335917891882309551ull,
    9351632189679053783ull,
    9359559436717774315ull,
    9363524429262089205ull,
    9365787027190969851ull,
    9294509163278678781ull,
    13763351606688443357ull,
    16105329319470675439ull,
    12646547385902554103ull,
    15528912531395440059ull,
    16970095377962743773ull,
    17690686806594149359ull,
    18123041209094876663ull,
    18266877968014825147ull,
    15942462577576736747ull,
    17266662019209477109ull,
    17838619103839641083ull,
    13530926300040916989ull,
    15988765917638555583ull,
    17289743320496192479ull,
    17868455907137805743ull,
    13545843602178371287ull,
    16959781046337760247ull,
    17703544039295399419ull,
    18147131010139544573ull,
    18278922872827932159ull,
    13823204778296326143ull,
    16135255630396775359ull,
    12679314662571224543ull,
    15545014694748804847ull,
    17828446075061493227ull,
    18137596173913927669ull,
    18292451322849384443ull,
    18441584922516237309ull,
    18426431573523158463ull,
    13824902903643630559ull,
    16117809093405177263ull,
    17282206213739428567ull,
    16967148169374810077ull,
    17706946125837213679ull,
    18148903792245051383ull,
    18298105133071976379ull,
    13832726909764625373ull,
    16121721097518445039ull,
    12672476198455081463ull,
    15559609861200215227ull,
    15954977407899730367ull,
    17272918334859346399ull,
    17860112683551916463ull,
    13541743458641215959ull,
    15976510572059656683ull,
    17283614548195115509ull,
    17847164637564994043ull,
    13535268336136126717ull,
    13789295794724880129ull,
    16118301409193992065ull,
    12670837822552772481ull,
    15540776553912452993ull,
    16993691043521487745ull,
    17720498758714388865ull,
    18155608640431978881ull,
    18283161958557088896ull
};

// Comparison function for fastest first heuristic
// Look at the endgame alphabeta function to see the array
// this is working on.
int ffComp(const void *a, const void *b) {
    // Want to compare the popcounts of the last of the three u64's.
    return PC(*((u64 *) a + 2)) - PC(*((u64 *) b + 2));
}

// Same function but only looking at last 8 bits
int ffComp2(const void *a, const void *b) {
    return (int) ((*((u64 *) a + 2)) & 0xFF) - (int) ((*((u64 *) b + 2)) & 0xFF);
}

// Same function as ffComp2 only looking at more bits
int ffComp3(const void *a, const void *b) {
    // This trusts that the u64's have values smaller than INT_MAX
    return (int) (*((u64 *) a + 2)) - (int) (*((u64 *) b + 2));
}

int alphabeta(u64 black, u64 white, int depth, int alpha, int beta) {
    // Deal with no legal moves possibility
    u64 lm = findLegalMoves(black, white);
    if (lm == 0) {
        lm = findLegalMoves(white, black);
        if (lm == 0) {
            return DD(black, white) * MAX_EVAL;
        }
        return -alphabeta(white, black, depth - 1, -beta, -alpha);
    }

    // Save initial board state
    u64 originalBlack = black;
    u64 originalWhite = white;

    // Return static evaluation at depth 0 or less (yes, less is possible due to lm == 0 case)
    if (depth <= 0) {
        return eval(black, white, lm);
    }
    else if (depth == 1) {
        // Main alphabeta algorithm
        while (lm && (alpha < beta)) {
            // Extract next legal move and make the move
            int index = CLZ(lm);
            lm ^= BIT(index);
            DO_MOVE(originalBlack, originalWhite, index, black, white);

            // Get eval
            int result = -eval(white, black, findLegalMoves(white, black));
            alpha = (result > alpha) ? result : alpha;
        }
        return alpha;
    }
        
    // Save original alpha and beta
    int originalAlpha = alpha;
    int originalBeta = beta;
    
    // Check midgame transposition table (same endgameTT is used for both to save space)
    #if COUNT_COLLISIONS
    int canCollide = 1; // To count collisions later
    #endif
    u32 hash;
    if (depth > STOP_USING_TT_DEPTH) {
        hash = boardHash(originalBlack, originalWhite);
        if (endgameTT[hash].black == originalBlack && endgameTT[hash].white == originalWhite) {
            #if COUNT_COLLISIONS
            canCollide = 0;
            ttHits++;
            #endif
            u64 data = endgameTT[hash].data;
            int d = EXTRACT_MIDGAME_TT_DEPTH(data);
            if (depth == d) {
                int ee = EXTRACT_MIDGAME_TT_EVAL(data);
                int a = EXTRACT_MIDGAME_TT_ALPHA(data);
                int b = EXTRACT_MIDGAME_TT_BETA(data);
                if (a < ee && ee < b) {
                    return ee;
                }
                else if (ee >= b && b >= beta) {
                    return beta;
                }
                else if (ee >= b) {
                    alpha = b;
                }
                else if (ee <= a && a <= alpha) {
                    return alpha;
                }
                else if (ee <= a) {
                    beta = a;
                }
            }
        }
    }

    // Iterative deepening
    if (depth > 4) {
        // Shallow alphabeta search
        int shallowResult = alphabetaMove(black, white, 2, alpha, beta);
        
        // Get first move to try
        u8 firstMove = EXTRACT_MOVE(shallowResult);

        // Try first move
        lm ^= BIT(firstMove);
        DO_MOVE(originalBlack, originalWhite, firstMove, black, white);

        // Recursive call and update alpha
        int result = -alphabeta(white, black, depth - 1, -beta, -alpha);
        if (result > alpha) alpha = result;
    }
    else if (depth > 2) {
        u8 firstMove = EXTRACT_MOVE(alphabetaMove(black, white, 1, alpha, beta));

        // Try first move
        lm ^= BIT(firstMove);
        DO_MOVE(originalBlack, originalWhite, firstMove, black, white);

        // Recursive call and update alpha
        int result = -alphabeta(white, black, depth - 1, -beta, -alpha);
        if (result > alpha) alpha = result;
    }

    // Fastest first heuristic while depth is large enough
    if (depth > 3) {
        // The legal moves will be ordered so that moves giving the opponent
        // less mobility appear first.

        // Array for moves, boards, and the number of legal moves each gives
        // Each "entry" is 2 * 8 (black and white boards) + 8 (score) = 3 * 8 bytes
        u64 arr[32 * 3];

        // Index to keep track of place in arrays
        u8 moveIndex = 0;

        // Total number of legal moves
        u8 numLegalMoves = PC(lm);

        // Loop through legal moves
        while (lm) {
            // Extract move
            u8 square = CLZ(lm);
            lm ^= BIT(square);

            // Make move
            DO_MOVE(originalBlack, originalWhite, square, black, white);

            // Store board, move, and number of opponent's legal moves
            arr[3 * moveIndex] = black;
            arr[3 * moveIndex + 1] = white;
            arr[3 * moveIndex + 2] = PC(findLegalMoves(white, black));

            // Update moveIndex
            moveIndex++;
        }

        // Sort
        qsort(arr, numLegalMoves, 3 * sizeof(u64), ffComp);

        // Main alphabeta algorithm
        for (size_t i = 0; alpha < beta && i < numLegalMoves; i++) {
            // Recursive call and update alpha
            int result = -alphabeta(arr[3 * i + 1], arr[3 * i], depth - 1, -alpha - 1, -alpha);
            if (result > alpha) {
                if (result >= beta) {
                    alpha = beta;
                    goto save_to_hash;
                }
                alpha = -alphabeta(arr[3 * i + 1], arr[3 * i], depth - 1, -beta, -result);
            }
        }
    }
    else {
        // Main alphabeta algorithm
        while (lm && (alpha < beta)) {
            // Extract next legal move and make the move
            int index = CLZ(lm);
            lm ^= BIT(index);
            DO_MOVE(originalBlack, originalWhite, index, black, white);

            // Recursive call, pvs, and update alpha
            int result = -alphabeta(white, black, depth - 1, -alpha - 1, -alpha);
            if (result > alpha) {
                // Failed high
                if (result >= beta) {
                    alpha = beta;
                    goto save_to_hash;
                }
                alpha = -alphabeta(white, black, depth - 1, -beta, -result);
            }
        }
    }

    save_to_hash:

    // Save results to hash
    if (depth > STOP_USING_TT_DEPTH) {
        #if 0
        if (endgameTT[hash].black 
                                  #if COUNT_COLLISIONS
                                  && canCollide
                                  #endif
                                  ) {
            #if COUNT_COLLISIONS
            collisions[hash]++;
            #endif
            // Replacement scheme is always replace
        }
        #endif
        endgameTT[hash].black = originalBlack;
        endgameTT[hash].white = originalWhite;
        endgameTT[hash].data = CONSTRUCT_MIDGAME_TT_DATA(alpha, originalAlpha, originalBeta, depth);
    }

    return alpha;
}

int alphabetaMove(u64 black, u64 white, int depth, int alpha, int beta) {
    // Deal with no legal moves possibility
    u64 lm = findLegalMoves(black, white);
    if (lm == 0) {
        lm = findLegalMoves(white, black);
        if (lm == 0) {
            return ((DD(black, white) * MAX_EVAL) * 256) | NULL_MOVE;
        }
        return (-alphabeta(white, black, depth - 1, -beta, -alpha) * 256) | NULL_MOVE;
    }

    // Return static evaluation at depth 0 or less (yes, less is possible due to lm == 0 case)
    if (depth <= 0) {
        return (eval(black, white, lm) * 256) | NULL_MOVE; // No move should be given for depth 0 search
    }
    
    // Save initial board state
    u64 originalBlack = black;
    u64 originalWhite = white;

    // Declare move
    u8 move = NULL_MOVE;

    // Iterative deepening
    if (depth > 1) {
        move = EXTRACT_MOVE(alphabetaMove(originalBlack, originalWhite, depth / 2, alpha, beta));

        // Try first move
        lm ^= BIT(move);
        DO_MOVE(originalBlack, originalWhite, move, black, white);

        // Recursive call and update alpha
        int result = -alphabeta(white, black, depth - 1, -beta, -alpha);
        if (result > alpha) alpha = result;
    }
    else {
        move = CLZ(lm);
        lm ^= BIT(move);
        DO_MOVE(originalBlack, originalWhite, move, black, white);
        int result = -alphabeta(white, black, depth - 1, -beta, -alpha);
        alpha = (alpha > result) ? alpha : result;
    }
    
    // Main alphabeta algorithm
    while (lm && (alpha < beta)) {
        // Extract next legal move and make the move
        u8 index = CLZ(lm);
        lm ^= BIT(index);
        DO_MOVE(originalBlack, originalWhite, index, black, white);

        // Recursive call, pvs, and update alpha
        int result = -alphabeta(white, black, depth - 1, -alpha - 1, -alpha);
        if (result > alpha) {
            // Failed high
            if (result >= beta) {
                alpha = beta; // This will break the loop before the next iteration
            }
            else {
                alpha = -alphabeta(white, black, depth - 1, -beta, -result);
            }
            move = index;
        }
    }

    return (alpha * 256) | move;
}

// For testing, [tc][blackLM][whiteLM]
long long mobilityWins[20][20] = {0};
long long mobilityLosses[20][20] = {0};

long long hits = 0;
int endgameAlphabeta(u64 black, u64 white, u64 lm, int beta) {
    // Save initial board state
    u64 originalBlack = black;
    u64 originalWhite = white;

    // Factor to multiply return value by (1 or -1)
    int factor = 1;

    // Deal with no legal moves possibility
    if (lm == 0) {
        lm = findLegalMoves(white, black);
        if (lm == 0) {
            return DD(black, white);
        }

        // Swap sides and set factor
        u64 temp = originalBlack;
        originalBlack = originalWhite;
        originalWhite = temp;
        factor = -1;
        beta = 1 - beta;
    }

    // Calculate total count for usage later
    int totalCount = TC(originalBlack, originalWhite);

    // Check endgame transposition table
    #if COUNT_COLLISIONS
    int canCollide = 1; // To count collisions later
    #endif
    u32 hash;
    if (totalCount < STOP_HASHING_TC) {
        hash = boardHash(originalBlack, originalWhite);
        if (endgameTT[hash].black == originalBlack && endgameTT[hash].white == originalWhite) {
            #if COUNT_COLLISIONS
            canCollide = 0;
            ttHits++;
            #endif
            u8 ee = endgameTT[hash].data;
            if (ee == BLACK_WIN || (ee == NOT_WHITE_WIN && beta == 0)) {
                return beta;
            }
            else if (ee == WHITE_WIN || (ee == NOT_BLACK_WIN && beta == 1)) {
                return beta - 1;
            }
        }
    }

    // Declare result variable (to store results of endgame searches, and later final result)
    int alpha = beta - 1;
    int result;

    // Total number of legal moves
    u8 numLegalMoves = PC(lm);

    // Try alphabeta search suggestion
    if (totalCount < STOP_USING_EVAL - ENDGAME_AB_DEPTH) {
        int abResult = alphabetaMove(originalBlack, originalWhite, ENDGAME_AB_DEPTH, MIN_EVAL, MAX_EVAL);
        u8 move = EXTRACT_MOVE(abResult);
        DO_MOVE(originalBlack, originalWhite, move, black, white);
        int result = -endgameAlphabeta(white, black, findLegalMoves(white, black), 1 - beta);
        if (result >= beta) {
            alpha = beta;
            goto save_to_hash;
        }

        // Remove move from lm
        lm ^= BIT(move);
        numLegalMoves--;
    }

    if (totalCount < STOP_SORTING_TC) {
        // The legal moves will be ordered so that moves giving the opponent
        // less mobility appear first.

        // Array for moves, boards, and the number of legal moves each gives
        // Each "entry" is 2 * 8 (black and white boards) + 8 (score) = 3 bytes
        u64 arr[numLegalMoves * 3];

        // Index to keep track of place in arrays
        u8 moveIndex = 0;

        // Loop through legal moves
        while (lm) {
            // Extract move
            u8 square = CLZ(lm);
            lm ^= BIT(square);

            // Make move
            DO_MOVE(originalBlack, originalWhite, square, black, white);

            // Store board, move, and number of opponent's legal moves
            arr[3 * moveIndex] = black;
            arr[3 * moveIndex + 1] = white;
            arr[3 * moveIndex + 2] = findLegalMoves(white, black);

            // Update moveIndex
            moveIndex++;
        }

        // Sort
        qsort(arr, numLegalMoves, 3 * sizeof(u64), ffComp);

        // Main alphabeta algorithm
        for (size_t i = 0; i < numLegalMoves; i++) {
            // Recursive call and update alpha
            int result;
            if (totalCount == 61) {
                result = -endgameAlphabeta62(arr[3 * i + 1], arr[3 * i], arr[3 * i + 2], 1 - beta);
            }
            else {
                result = -endgameAlphabeta(arr[3 * i + 1], arr[3 * i], arr[3 * i + 2], 1 - beta);
            }
            if (result >= beta) {
                alpha = beta;
                break;
            }
        }
    }
    else {
        // Main alphabeta algorithm
        while (lm) {
            // Extract move
            u8 square = CLZ(lm);
            lm ^= BIT(square);

            // Recursive call and update alpha
            DO_MOVE(originalBlack, originalWhite, square, black, white);
            int result;
            if (totalCount == 61) {
                result = -endgameAlphabeta62(white, black, findLegalMoves(white, black), 1 - beta);
            }
            else {
                result = -endgameAlphabeta(white, black, findLegalMoves(white, black), 1 - beta);
            }
            if (result >= beta) {
                alpha = beta;
                break;
            }
        }
    }
        

    save_to_hash:
    result = factor * alpha;

    // Save results to hash
    if (totalCount < STOP_HASHING_TC) {
        #if 0
        if (endgameTT[hash].black 
                                  #if COUNT_COLLISIONS
                                  && canCollide
                                  #endif
                                  ) {
            #if COUNT_COLLISIONS
            collisions[hash]++;
            #endif
            // Replacement scheme is always replace
        }
        #endif
        endgameTT[hash].black = originalBlack;
        endgameTT[hash].white = originalWhite;
        if (alpha == 1) {
            endgameTT[hash].data = BLACK_WIN;
        }
        else if (alpha == -1) {
            endgameTT[hash].data = WHITE_WIN;
        }
        else if (alpha == beta) {
            endgameTT[hash].data = NOT_WHITE_WIN;
        }
        else {
            endgameTT[hash].data = NOT_BLACK_WIN;
        }
    }

    return result;
}

int endgameAlphabeta63(u64 black, u64 white, int beta) {
    // Originals
    u64 originalBlack = black;

    // Empty square
    u8 square = CLZ(~(black | white));

    // Check if last move matters
    u64 mask = SAFE_MASK[square];
    if (PC(black & mask) >= 32 + beta) return 1;
    if (PC(white & mask) >= 33 - beta) return -1;

    // Make move
    black = doMove(black, white, square);
    
    // Was move legal?
    if (black != originalBlack) return PC(black) - 32; // Multiply times 2 if care about disc difference
    
    // Try white
    DO_MOVE_IN_PLACE(white, black, square);

    // Compute result
    return DD(black, white);
}

int endgameAlphabeta62(u64 black, u64 white, u64 lm, int beta) {
    int factor = 1;
    if (lm == 0) {
        lm = findLegalMoves(white, black);
        if (lm == 0) {
            return DD(black, white);
        }

        // Swap sides and set factor
        u64 temp = black;
        black = white;
        white = temp;
        factor = -1;
        beta = 1 - beta;
    }

    // Extract moves
    u8 square63 = CLZ(lm);
    lm ^= BIT(square63);
    u64 mask = SAFE_MASK[square63];

    
    if (lm) {
        mask &= SAFE_MASK[CLZ(lm)];
        if (PC(black & mask) >= 32 + beta) return factor * 1;
        if (PC(white & mask) >= 33 - beta) return factor * -1;
        
        u64 black1, black2, white1, white2;

        // Make move
        DO_MOVE(black, white, square63, black1, white1);
        int best = -endgameAlphabeta63(white1, black1, 1 - beta);
        if (best >= beta) return factor * beta;

        // Try other move
        square63 = CLZ(lm);
        DO_MOVE(black, white, square63, black2, white2);
        int secondEval = -endgameAlphabeta63(white2, black2, 1 - beta);
        return factor * secondEval;
    }

    // Make move
    DO_MOVE_IN_PLACE(black, white, square63);
    
    // Compute result
    return -factor * endgameAlphabeta63(white, black, 1 - beta);
}

int endgameAlphabetaMove(u64 black, u64 white, int alpha, int beta) {
    // Deal with no legal moves possibility
    u64 lm = findLegalMoves(black, white);
    if (lm == 0) {
        lm = findLegalMoves(white, black);
        if (lm == 0) {
            return (DD(black, white) * 256) | NULL_MOVE;
        }
        return (-endgameAlphabeta(white, black, lm, -alpha) * 256) | NULL_MOVE;
    }
    
    // Set default move
    u8 move = CLZ(lm);
    
    // Save initial board state
    u64 originalBlack = black;
    u64 originalWhite = white;

    // Calculate total count for usage later
    int totalCount = TC(originalBlack, originalWhite);

    // Declare result variable (to store results of endgame searches, and later final result)
    int result;

    // Try alphabeta search suggestion
    if (totalCount < STOP_USING_EVAL - ENDGAME_AB_DEPTH) {
        int abResult = alphabetaMove(originalBlack, originalWhite, ENDGAME_AB_DEPTH, MIN_EVAL, MAX_EVAL);
        move = EXTRACT_MOVE(abResult);
        DO_MOVE(originalBlack, originalWhite, move, black, white);
        result = -endgameAlphabeta(white, black, findLegalMoves(white, black), -alpha);
        alpha = (result > alpha) ? result : alpha;

        // Check if this move is good enough to return immediately
        if (alpha >= beta) return (256 * beta) | move;
        
        // Remove tried move from lm
        lm ^= BIT(move);
    }

    // Total number of legal moves
    u8 numLegalMoves = PC(lm);

    // The legal moves will be ordered so that moves giving the opponent
    // less mobility appear first.

    // Array for moves, boards, and the number of legal moves each gives
    // Each "entry" is 2 * 8 (black and white boards) + 8 (score) = 3 bytes
    u64 arr[numLegalMoves * 3];

    // Index to keep track of place in arrays
    u8 moveIndex = 0;

    // Loop through legal moves
    while (lm) {
        // Extract move
        u8 square = CLZ(lm);
        lm ^= BIT(square);

        // Make move
        DO_MOVE(originalBlack, originalWhite, square, black, white);

        // Store board, move, and number of opponent's legal moves
        arr[3 * moveIndex] = black;
        arr[3 * moveIndex + 1] = white;
        arr[3 * moveIndex + 2] = ((u64) square << 56) | PC(findLegalMoves(white, black));

        // Update moveIndex
        moveIndex++;
    }

    // Sort
    qsort(arr, numLegalMoves, 3 * sizeof(u64), ffComp2);

    // Main alphabeta algorithm
    for (size_t i = 0; alpha < beta && i < numLegalMoves; i++) {
        // Recursive call and update alpha
        int result = -endgameAlphabeta(arr[3 * i + 1], arr[3 * i], findLegalMoves(arr[3 * i + 1], arr[3 * i]), -alpha);
        if (result > alpha) {
            alpha = result;
            move = arr[3 * i + 2] >> 56;
        }
    }

    return (alpha * 256) | move;
}

